Assignment 5
------------

1.

  (i)
    Powers of two have all zeros except a single 1 according to which power
    they are: 
    4   =   0000100
    16  =   0010000
    64  =   1000000
    ...
    2^n =   1 and n zeroes afterwards
    
    Taking remainder of some binary number on 2^n means picking n last figures
    from that number. 
    E.g. 110100110 remainder on 16 (10000) would be 0110 = 110
              ----                   ----
    That can be achieved by AND-ing number on bit pattern which has all zeroes
    except last n ones:
              110100110
        AND   000001111
              ---------
              000000110
    
    To get that pattern, we just have to take 2^n - 1.
    So, the algorithm would read like this:
    
    def remainder(num, n):
      return num AND (2**n - 1)
    end
    
  (ii)
    In twos complement system we flip bits and add one.
    Flipping is done with NOT operator and adding one is done by adding one.
    
    def sigchange(num):
      return NOT num + 1
    end
    
    EDIT: NOT is done by XOR-ing on all ones, that is on -1:
    
    def sigchange2(num):
      return (num XOR -1) + 1
    end
    
  (iii)
    If your file is n bits you should get a secret random n bit pattern and 
    XOR with it (actually it can be any number of bits less than n but you'll
    have to XOR repeatedly all the parts of the file).
    XOR-ing it again with secret key will retrieve initial file.
    
2.
  This was a rhetorical question.
  
3.
  (i)
    ****
    (gdb) x/s text
    0x400574:	"hi!"
    (gdb) x/d text
    0x400574:	104
    (gdb) x/i text
    0x400574:	pushq  $0x1002169
    (gdb) x/c text
    0x400574:	104 'h'
    (gdb) x/hu text
    0x400574:	26984
    (gdb) x/a text
    0x400574:	0x3b031b0100216968
    (gdb) x/t text
    0x400574:	0011101100000011000110110000000100000000001000010110100101101000
    (gdb) x/t 0x400574
    0x400574:	0011101100000011000110110000000100000000001000010110100101101000

    ****
    (gdb) x/d &num
    0x7fffffffdd9c:	3
    (gdb) x/f &num
    0x7fffffffdd9c:	4.20389539e-45
    (gdb) x/c &num
    0x7fffffffdd9c:	3 '\003'
    
    Idea was that we can interpret pure data as we want, as long as the
    language gives us the means.
    Which it does in case of C.
    
  (ii)
    Little and big-endian differ by byte ordering.
    E.g. unsigned short 5 takes 8 bits to represent, which in big-endian will
    look like:
      0000 0101.
      ---------
    That follows 'natural' way of representing data.
    In little-endian systems bytes are swapped:
      0101 0000
      ---------
  
    To find out endiannes, we have to take two chars, '\0' and 'A'.
    Putting them together, "\0A" would give 65 in big endian.
    In little endian same string would correspond to some large number.
    
    void main()
    {
        char first = '\0';
        char second = 'A';
        unsigned short num;
        memcpy(&num, &first, 1);
        memcpy((char*) &num + 1, &second, 1);
        if(num == 65)
            printf("big endian..\n");
        else
            printf("little endian.. \n");
    }
  
    My Intel chip turns out to be little-endian.
    
4.
  (i)
    Using only pointers:
  
    void foo() {
      int** a;
      int* b;
      a[0] = b + 1;
    }
  
  
  (ii)
    Using only int
    
    void bar() {
      int num[2];
      * (int*) num[1] = num[0] + 4;
    }
    
5.

  const size_t num = kHeapSize - sizeOf(list) + 1;
  
  bool inBounds(void* pointer) {
    return (pointer >= kHeapStart && ptr < (void*) ( (char*) kHeapStart + num) );
  }

  bool foo() {
  
    // Pay attention to for loop bounds.
    for(int i = 0; i < num; i++) {
      list* addr = (list*) ( (char*) kHeapStart + i);
      
      if( addr -> data == 1) {
        list* p1 = addr -> next;
        if( !inBounds(p1) ) continue;
        
        if( p1 -> data == 2) {
          list* p2 = p1 -> next;
          if( !inBounds(p2) ) continue;
        
          if( p2 -> data == 3) {
            list* p3 = p2 -> next;
            if( !inBounds(p3) ) continue;
            
            if( p3 -> next == NULL) return true;
          }
        }
      }
    }
    
    return false;
  }  
  
  Code is a little sloppy but the idea is clear.
  
6.
  
  (a)
    // line 1
    SP = SP - 4                   // make space for bubs
    
    // line 2
    R1 = M[SP + 8]                // load strongmad.coachz value
    R2 = M[SP + 24]               // load marzipan value
    R3 = R2 + 4                   // calc address marzipan->thecheat
    R4 = R3 + 4 * R1    // calc address of marzipan->thecheat[strongmad.coachz]
    R5 = M[R4]                    // load value at R4
    R6 = .2 M[R5]                 // deref short* R5
    R7 = .1 M[SP]                 // bubs[0] as char
    R8 = SP + R7                  // addr of bubs[*bubs]
    M[R8] = .1 R6                 // finish
    
    // line 3
    R1 = M[SP]                    // * (int*) bubs value
    R2 = SP + 24                  // line 3 lhs address
    R3 = M[R2]                    // line 3 lhd value
    R1 = R1 * 4                   // scale R1 for pointer arithmetic
    R4 = R3 + R1                  // actual arithmetic
    M[R2] = R4                    // write
    
    SP = SP + 4                   // roll back to saved PC
    RET
    
  (b)
    // no local vars
    SP = SP - 0
    
    // lay down parameters for function call
    SP = SP - 8                   // make space
    R1 = M[SP + 12]               // 8 up to saved PC and 4 more up for marshie
    M[SP + 4] = R1                // put that address as second parameter
    R2 = M[SP + 16]               // 8 up to saved PC and 8 more up for mrshmallow
    M[SP] = R2                    // lay down first parameter
    
    CALL <puppetthing>            // actual call

    SP = SP + 8                   // come back up where we were
    
    R1 = M[RV]                    // one deref of returned address
    RV = M[R1 + 12]               // return value loaded
        
    SP = SP + 0                   // local vars cleanup
    
    RET


