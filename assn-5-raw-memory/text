Assignment 5
------------

1.

  (i)
    Powers of two have all zeros except a single 1 according to which power
    they are: 
    4   =   0000100
    16  =   0010000
    64  =   1000000
    ...
    2^n =   1 and n zeroes afterwards
    
    Taking remainder of some binary number on 2^n means picking n last figures
    from that number. 
    E.g. 110100110 remainder on 16 (10000) would be 0110 = 110
              ----                   ----
    That can be achieved by AND-ing number on bit pattern which has all zeroes
    except last n ones:
              110100110
        AND   000001111
              ---------
              000000110
    
    To get that pattern, we just have to take 2^n - 1.
    So, the algorithm would read like this:
    
    def remainder(num, n):
      return num AND (2**n - 1)
    end
    
  (ii)
    In twos complement system we flip bits and add one.
    Flipping is done with NOT operator and adding one is done by adding one.
    
    def sigchange(num):
      return NOT num + 1
    end
    
    EDIT: NOT is done by XOR-ing on all ones, that is on -1:
    
    def sigchange2(num):
      return (num XOR -1) + 1
    end
    
  (iii)
    If your file is n bits you should get a secret random n bit pattern and 
    XOR with it (actually it can be any number of bits less than n but you'll
    have to XOR repeatedly all the parts of the file).
    XOR-ing it again with secret key will retrieve initial file.
    
2.
  This was a rhetorical question.
  
3.
  (i)
    ****
    (gdb) x/s text
    0x400574:	"hi!"
    (gdb) x/d text
    0x400574:	104
    (gdb) x/i text
    0x400574:	pushq  $0x1002169
    (gdb) x/c text
    0x400574:	104 'h'
    (gdb) x/hu text
    0x400574:	26984
    (gdb) x/a text
    0x400574:	0x3b031b0100216968
    (gdb) x/t text
    0x400574:	0011101100000011000110110000000100000000001000010110100101101000
    (gdb) x/t 0x400574
    0x400574:	0011101100000011000110110000000100000000001000010110100101101000

    ****
    (gdb) x/d &num
    0x7fffffffdd9c:	3
    (gdb) x/f &num
    0x7fffffffdd9c:	4.20389539e-45
    (gdb) x/c &num
    0x7fffffffdd9c:	3 '\003'
    
    Idea was that we can interpret pure data as we want, as long as the
    language gives us the means.
    Which it does in case of C.
    
  (ii)
    Little and big-endian differ by byte ordering.
    E.g. unsigned short 5 takes 8 bits to represent, which in big-endian will
    look like:
      0000 0101.
      ---------
    That follows 'natural' way of representing data.
    In little-endian systems bytes are swapped:
      0101 0000
      ---------
  
    To find out endiannes, we have to take two chars, '\0' and 'A'.
    Putting them together, "\0A" would give 65 in big endian.
    In little endian same string would correspond to some large number.
    
    void main()
    {
        char first = '\0';
        char second = 'A';
        unsigned short num;
        memcpy(&num, &first, 1);
        memcpy((char*) &num + 1, &second, 1);
        if(num == 65)
            printf("big endian..\n");
        else
            printf("little endian.. \n");
    }
  
    My Intel chip turns out to be little-endian.
    
4.
  (i)
    Using only pointers:
  
    void foo() {
      int** a;
      int* b;
      a[0] = b + 1;
    }
  
  
  (ii)
    Using only int
    
    void bar() {
      int num[2];
      * (int*) num[1] = num[0] + 4;
    }
    
5.
    
  
  
  
  
    

